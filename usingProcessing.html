<!DOCTYPE html>
<html> 
 <head>
    <title>Project Johan Andres Ochoa</title> 
</head>
 <body>
    <p align="center"> 
      <canvas id="mycanvas"></canvas> 
    </p>
 </body>
 
 <script src="https://cdn.jsdelivr.net/processing.js/1.4.8/processing.min.js"></script> 
 
 <script>
    const sketchProc = (processingInstance) => {
     with (processingInstance) {
        //THE FOLLOWING CODE IS WRITEN BY JOHAN ANDRES OCHOA
        //jandresochoa91@gmail.com
       
        //WHEN I USE X AND Y, I USUALLY REFFER TO X AXIS AND Y AXIS. 
        //Example: sizeXStar, randomXForCharacters, randomXForClouds, etc

        //I'VE USED *** IN COMMENTS TO REFFER FUNCTIONS IN THE DRAW FUNCTION (MAIN)

        size(800, 650); 
        frameRate(300);

        //INTRODUCTION
        let isIntroduction = true;
        //Introduction function in DrawFunction
        const introduction = () => {
          fill(255, 255, 255, 230);
          rect(150, 10, 500, 630);
          fill(0, 0, 0);
          textSize(40); 
          text("Hello Code the Dream", 200, 60);
          textSize(30); 
          text(`My name is Johan Andres Ochoa, \nand this is my personal project \ncalled "UFO in San Francisco". \n\nThis is a videogame that I have \ncreated using ProcessingJS, the \nlibrary suggested in Khan \nAcademy, and also using some \nprior knowledge that I already have \nin JavaScript. \n\nThank you for the opportunity and I \nhope you like my creation.`, 
                165,
                110
          );            
          stroke(0, 0, 0);
          fill(255, 255, 255);
          rect(225, 540, 350, 80);
          fill(0, 0, 0);
          textSize(40)
          text("START PLAYING", 245, 590);
          mousePressed = () => {
            if (mouseX > 225 && mouseX < 575 && mouseY > 540 && mouseY < 620) {
              isIntroduction = false;
            }
          }
        };


        //INSTRUCTIONS
        let isKeyPressed = true;
        //Instructions function in DrawFunction
        const instructions = () => {
          fill(255, 255, 255, 230);
          rect(125, 120, 550, 450);
          fill(0, 0, 0);
          textSize(40); 
          text("Instructions", 290, 160);
          textSize(20); 
          text(`Your mission is to catch the required number of aliens in \nless than 30 seconds.\n\nYou can move the UFO with the cursor (mouse) and catch \nthe aliens with the UFO beam by CLICKING. \n\nThe beam you catch aliens with can only be generated by \nCLICKING ON THE UFO.You can only move the UFO just \nabove the Painted Ladies (The coloured houses). \n\nYou can pause or come back to the instructions by pressing \nENTER.`, 
                135,
                200
          );
          textSize(30)
          text(`Press ENTER to play`, 260, 520);  

          keyPressed = () => {
            if (keyCode === ENTER) {
              if (isKeyPressed) {
                isKeyPressed = false;
              } else {
                isKeyPressed = true;
              }
            } 
          }
        };

        //SKY
        let colorOfSky = [0, 228, 255];

        //***Sky function in Draw function
        const sky =  () => {
          background(colorOfSky[0], colorOfSky[1], colorOfSky[2]);
          if (sunMovement < -400 && colorOfSky[2] > 0) {
            if (colorOfSky[1] > 0) {
              colorOfSky[1] -= 5;
            } else {
              colorOfSky[1] = 0;
              if (colorOfSky[2] <= 40) {
                colorOfSky[2] = 40;    //Defined 40 because I didn't want the sky to be totally black
              } else {
                colorOfSky[2] -= 5;
              }
            }
          } else if (sunMovement > -200 && colorOfSky[1] < 228) {  //When the sun.....
            if (colorOfSky[2] < 255) {
              colorOfSky[2] += 4;
            } else {
              colorOfSky[1] += 4;
            }
          }
        };  


        //SUN
        let sunMovement = 380;
        
        //***Sun function in Draw function
        const sun = () => {
          fill(255, 255, 0);
          noStroke();
          ellipse(200, sunMovement, 200, 200);
          noFill();
          stroke(0, 0, 0);
          strokeWeight(3);
          arc(200, sunMovement, 150, 100, 0, PI);
          ellipse(250, sunMovement, 10, 10);
          ellipse(153, sunMovement, 10, 10);
          fill(0, 0, 0);
          sunMovement -= 5;
          
          if (colorOfSky[2] <= 60 && sunMovement === -1300) {    //Separate in different functions
            sunMovement = 750;
          }
        };


        //MOON
        let moveMoonX = 850;
        let moveMoonY = 200;
        let moonPhase = 1;    //There are 3 phases in this code: 1: Waxing Crescent, 2: First Quarter, 3: Full.

        //***Moon function in Draw function
        const moon = () => {
          if (colorOfSky[2] <= 160) {
            noStroke();
            fill(255, 255, 255);
            ellipse(moveMoonX, moveMoonY, 50, 50);

            if (moonPhase === 1) {
              fill(colorOfSky[0], colorOfSky[1], colorOfSky[2]);
              ellipse(moveMoonX - 10, moveMoonY, 50, 50);
            } else if (moonPhase === 2) {
              fill(colorOfSky[0], colorOfSky[1], colorOfSky[2]);
              rect(moveMoonX - 50, moveMoonY - 30, 50, 70);
            } else if (moonPhase > 3) {
              moonPhase = 1
            }
            moveMoonX -= 2;
            moveMoonY -= 2;
          } else {
            moveMoonX = 850;
            moveMoonY = 200;
          }
          if (colorOfSky[2] === 161) {
            moonPhase += 1;
          }
        };


        //STARS
        let sizeXStar = 0.001;
        let sizeYStar = 0.001;
        let isMidnight = false;

        //Array with position of random stars
        let allTheStars = [];
        for (let i = 0; i < 50; i++) {
          let randomXStars = random(0, 800);
          let randomYStars = random(0, 400);
          allTheStars.push([randomXStars, randomYStars]); 
        }

        //***Stars function in Draw function
        const stars = () => {
          for (var i = 0; i < allTheStars.length; i++) {
            
            if (colorOfSky[2] < 255) {              
              fill(255, 255, 255);
              noStroke();
              ellipse(allTheStars[i][0], allTheStars[i][1], sizeXStar, sizeYStar);
              
              if (isMidnight) {
                sizeXStar -= 0.001;
                sizeYStar -= 0.001;
              } else {
                sizeXStar += 0.001;
                sizeYStar += 0.001;
              }
              
              if (sizeXStar > 4) {
                sizeXStar -= 0.001;
                sizeYStar -= 0.001;
                isMidnight = true;
              } 

              if (colorOfSky[2] > 250) {
                sizeXStar = 0.001;
                sizeYStar = 0.001;
                isMidnight = false;
              }
            } 
          }
        };


        //TRANSAMERICA PYRAMID BUILDING
        //***Pyramid function in Draw function
        const pyramid = () =>  {
          stroke(0, 0, 0);
          strokeWeight(3);
          let randomRPyramidColor = random(0, 255);
          let randomGPyramidColor = random(0, 255);
          let randomBPyramidColor = random(0, 255);

          if (colorOfSky[2] < 255) {
            fill(randomRPyramidColor, randomGPyramidColor, randomBPyramidColor);
          } else {
            fill(buildingsAttributes[0][3][0],  //I used position 0, but you can use any other position of the array
                 buildingsAttributes[0][3][1],  //I used position 0, but you can use any other position of the array
                 buildingsAttributes[0][3][2]   //I used position 0, but you can use any other position of the array
            );
          }

          triangle(100, 450, 150, 150, 200, 450);
          rect(140, 225, 20, 70);
        };


        //SALESFORCE BUILDING
        //***Salesforse function in Draw function
        const salesforce = () => {
          let randomRSalesforceColor = random(0, 255);
          let randomGSalesforceColor = random(0, 255);
          let randomBSalesforceColor = random(0, 255);

          if (colorOfSky[2] < 255) {
            fill(randomRSalesforceColor, randomGSalesforceColor, randomBSalesforceColor);
          } else {
            fill(buildingsAttributes[1][3][0],  //I used position 1, but you can use any other position of the array
                 buildingsAttributes[1][3][1],  //I used position 1, but you can use any other position of the array
                 buildingsAttributes[1][3][2]   //I used position 1, but you can use any other position of the array
            );
          }

          stroke(0, 0, 0);
          strokeWeight(3);
          ellipse(520, 270, 50, 370);

          strokeWeight(3);
          line(505, 120, 534, 120);

          noStroke();
          fill(colorOfSky[0], colorOfSky[1], colorOfSky[2]);
          rect(500, 79, 40, 40);
        };
        

        //CLOUDS
        //Clouds attributes
        let cloudsAttributes = []; 
        let rgbCloudsColor = 255;

        for (let i = 1; i < 7; i++) {
          let randomXForClouds = random(0, 800);
          let setYForClouds = (50 * i) - 50;
          let randomSpeedForClouds = random(1, 5);

          cloudsAttributes.push([setYForClouds,  
                                 randomSpeedForClouds,
                                 randomXForClouds
                                ]
          );          
        }

        //***Clouds function in Draw function
        const clouds = () => {
          noStroke();
          fill(rgbCloudsColor, rgbCloudsColor, rgbCloudsColor);

          for (let i = 0; i < cloudsAttributes.length; i++) {
            let xCloud = cloudsAttributes[i][0];
            ellipse(cloudsAttributes[i][2]     , xCloud, 126, 97);
            ellipse(cloudsAttributes[i][2] + 62, xCloud, 70 , 60);
            ellipse(cloudsAttributes[i][2] - 62, xCloud, 70 , 60);
            
            if (i % 2 === 0) {
              if (cloudsAttributes[i][2] > 1000) {
                cloudsAttributes[i][2] = -200;
              } else {
                cloudsAttributes[i][2] += cloudsAttributes[i][1];
              }
            } else {
              if (cloudsAttributes[i][2] < -100) {
                cloudsAttributes[i][2] = 1000;
              } else {
                cloudsAttributes[i][2] -= cloudsAttributes[i][1];
              }
            }
          }
        };


        //BUILDINGS (NEITHER TRANSAMERICA PYRAMID NOR SALESFORCE INCLUIDED)
        //Array of random mumbers to make buildings and define colors
        let buildingsAttributes = [];
        for (let i = 0; i < 60; i++) {
          let randomXForBuildings = random(-40, 800);
          let randomWeigthOfBuildings = random(30, 50);
          let randomHeightOfBuildings = random(-200, -100);
          let randomRForBuildingColor = random(140, 180);
          let randomGForBuildingColor = random(140, 180);
          let randomBForBuildingColor = random(140, 180);
          buildingsAttributes.push([randomXForBuildings,
                                    randomWeigthOfBuildings,
                                    randomHeightOfBuildings,
                                    [randomRForBuildingColor, randomGForBuildingColor, randomBForBuildingColor]
                                   ]
          );
        }

        //***Buildings function in Draw function
        const buildings = () => {
          stroke(0, 0, 0);

          for (let j = 0; j < buildingsAttributes.length; j++) {
          
            let randomRBuildingsColor = random(0, 255);
            let randomGBuildingsColor = random(0, 255);
            let randomBBuildingsColor = random(0, 255);

            if (colorOfSky[2] < 255) {
              fill(randomRBuildingsColor, randomGBuildingsColor, randomBBuildingsColor);
            } else {
              fill(buildingsAttributes[j][3][0], buildingsAttributes[j][3][1], buildingsAttributes[j][3][2]);
            }

            stroke(0, 0, 0);
            strokeWeight(3);
            rect(buildingsAttributes[j][0],
                                       400,
                 buildingsAttributes[j][1],
                 buildingsAttributes[j][2]
            );
          }
        };
 

        //PAINTED LADIES
        let colorsForPaintedLadies = {
          1: [255, 100, 100],
          2: [255, 150,  60],
          3: [255, 255, 100],
          4: [100, 255, 100],
          5: [84,  89,  255],
          6: [133, 100, 255]
        };

        //***Painted Ladies function in Draw function
        const paintedLadies = () => {
          fill(225, 204, 127);
          let movePaintedLadyToX = -10;
          let movePaintedLadyToY = -60;
          let randomNumberChangingPaintedLadies = Math.round(random(1, 2));
            
          for (let i = 1; i < 6 + 1; i++) {            
            if (colorOfSky[2] < 255) {
              if (randomNumberChangingPaintedLadies % 2 === 0) {
                fill(random(0, 255), random(0, 255), random(0, 255));
              } else {
                fill(colorsForPaintedLadies[i][0], colorsForPaintedLadies[i][1], colorsForPaintedLadies[i][2]);  
              }           
            } else {
              fill(colorsForPaintedLadies[i][0], colorsForPaintedLadies[i][1], colorsForPaintedLadies[i][2]);
            }
            stroke(0, 0, 0);
            strokeWeight(3);
            rect(10 + movePaintedLadyToX, 450 + movePaintedLadyToY, 120, 180);
            triangle(5  + movePaintedLadyToX, 450 + movePaintedLadyToY,
                    70  + movePaintedLadyToX, 385 + movePaintedLadyToY,
                    135 + movePaintedLadyToX, 450 + movePaintedLadyToY
            );
            quad(130 + movePaintedLadyToX, 450 + movePaintedLadyToY,
                 130 + movePaintedLadyToX, 630 + movePaintedLadyToY,
                 265 + movePaintedLadyToX, 610 + movePaintedLadyToY,
                 265 + movePaintedLadyToX, 440 + movePaintedLadyToY
            );
            fill(40, 40, 40);
            quad(70 + movePaintedLadyToX, 385 + movePaintedLadyToY,
                135 + movePaintedLadyToX, 450 + movePaintedLadyToY,
                270 + movePaintedLadyToX, 440 + movePaintedLadyToY,
                200 + movePaintedLadyToX, 380 + movePaintedLadyToY
            );
            movePaintedLadyToX += 130;
            movePaintedLadyToY -= 10;
          }             
        };

        
        //REDUCTION COLOR NIGHT   
        let blackenedColor = 0;   //Applied in Characters and Crosswalk, street and grass. 
        const reductionColorNight = () => {
          if (colorOfSky[2] < 255) {
            if (isMidnight) {
              blackenedColor += 0.8;
              rgbCloudsColor += 2.1
            } else {
              blackenedColor -= 1;
              rgbCloudsColor -= 2.1;
            }
          } 
          if (colorOfSky[2] > 250) {
            blackenedColor = 0;
            rgbCloudsColor = 255;
          }
        }
        reductionColorNight();


        //CROSSWALK, STREET AND GRASS
        //***function in Draw function
        const crosswalkStreetAndGrass = () => {
          stroke(0, 0, 0);
          strokeWeight(3);

          //Crosswalk
          fill(80 + blackenedColor, 80 + blackenedColor, 80 + blackenedColor);
          quad(0, 650, 0, 570, 1000, 495, 650, 800);
          
          //Street
          fill(120 + blackenedColor, 120 + blackenedColor, 120 + blackenedColor);
          quad(0, 650, 0, 580, 1000, 505, 650, 800);
          
          //Upper Green field
          fill(0, 180 + blackenedColor, 0);
          quad(0, 650, 0, 570, 1000, 610, 650, 800);
          
          //Lower Green Field
          fill(0, 255 + blackenedColor, 0);
          rect(0, 620, 800, 30);
        };


        //CHARACTERS
        //Random positions and speed for characters 
        let positionsAndSpeedOfCharacters = [];
        for (let i = 0; i < 3; i++) {
          let randomXForCharacters = random(0, 740);
          let randomYForCharacters = random(0, 45);
          let randomSpeedForCharacters = random(1, 30);
          let randomNewPositionOfCharacters = random(0, 800);
          positionsAndSpeedOfCharacters.push([randomXForCharacters,   
                                              randomYForCharacters,
                                              randomSpeedForCharacters,
                                              randomNewPositionOfCharacters,
                                              true     //True or false to know if caracter is turning right or left
                                             ]
          );
        }

        //***Characters function in Draw function
        const characters = () => {
          for (let i = 0; i < positionsAndSpeedOfCharacters.length; i++) {
            if (colorOfSky[0] < 255) {
              if (isMidnight) {
                
              }
            }
            noStroke();
            
            fill(0, 0, 0);
            ellipse(positionsAndSpeedOfCharacters[i][0], 643 - positionsAndSpeedOfCharacters[i][1], 15, 10);
            
            stroke(0, 0, 0);
            strokeWeight(1);

            fill(255 + blackenedColor, 60 + blackenedColor, 0);
            ellipse(positionsAndSpeedOfCharacters[i][0], 633 - positionsAndSpeedOfCharacters[i][1], 30, 20);
            
            fill(80 + blackenedColor, 254 + blackenedColor, 104 + blackenedColor);
            ellipse(positionsAndSpeedOfCharacters[i][0], 609 - positionsAndSpeedOfCharacters[i][1], 50, 40);
            
            stroke(0, 0, 0);
            strokeWeight(2)            
            arc(-12  + positionsAndSpeedOfCharacters[i][0], 613 - positionsAndSpeedOfCharacters[i][1], 8 ,  10, -3,  0);
            arc(12  + positionsAndSpeedOfCharacters[i][0], 613 - positionsAndSpeedOfCharacters[i][1], 8 ,  10, -3,  0);
            fill(0, 0, 0);
            arc(positionsAndSpeedOfCharacters[i][0], 620 - positionsAndSpeedOfCharacters[i][1], 12,  10,  0, PI);
            
            if (positionsAndSpeedOfCharacters[i][3] > positionsAndSpeedOfCharacters[i][0] && positionsAndSpeedOfCharacters[i][4]) {
              positionsAndSpeedOfCharacters[i][0] += positionsAndSpeedOfCharacters[i][2];
            } else {
              if (positionsAndSpeedOfCharacters[i][4]) {
                positionsAndSpeedOfCharacters[i][4] = false;
                positionsAndSpeedOfCharacters[i][3] = random(-400, 1200);
              }
            }

            if (positionsAndSpeedOfCharacters[i][3] <= positionsAndSpeedOfCharacters[i][0] && !positionsAndSpeedOfCharacters[i][4]) {
              positionsAndSpeedOfCharacters[i][0] -= positionsAndSpeedOfCharacters[i][2];
            } else {
              if (!positionsAndSpeedOfCharacters[i][4]) {
                positionsAndSpeedOfCharacters[i][4] = true;
                positionsAndSpeedOfCharacters[i][3] = random(-400, 1200);
              }
            }
          }
        };
        

        //UFO
        //***ufo function in Draw function
        const ufo = () => {
          let mouseXForUFO = mouseX;
          let mouseYForUFO = mouseY;
          let sizeOfUFO = mouseYForUFO * 0.006;

          if (mouseYForUFO > 220) {
            mouseYForUFO = 220;
            sizeOfUFO = 1.3;
          }
          stroke(0, 0, 0);
          strokeWeight(3);
          fill(38, 25, 25);
          ellipse(mouseXForUFO, mouseYForUFO + (sizeOfUFO * 1) ,  70 * sizeOfUFO, 70 * sizeOfUFO);
          fill(112, 59, 112);
          ellipse(mouseXForUFO, mouseYForUFO + (sizeOfUFO * 15), 150 * sizeOfUFO, 50 * sizeOfUFO);
          noStroke()
          fill(255, 255, 255);
          ellipse(mouseXForUFO, mouseYForUFO + (sizeOfUFO * 30),  70 * sizeOfUFO, 25 * sizeOfUFO);
        };


        //LIGHT OF UFO
        //***Light of UFO function in Draw function
        const lightOfUFO = () => {  //Change light
          mousePressed = () => {
            if (currentScore < goal && countdown > 0) {
              let mouseXForAbductionLight = mouseX;
              let mouseYForAbductionLight = mouseY;
              let sizeOfLight = mouseYForAbductionLight * 0.006;
              let isThereLight = false;
              if (mouseYForAbductionLight > 210) {
                mouseYForAbductionLight = 220;
                sizeOfLight = 1.3;
              }
              if (mouseY < 270) {
                noStroke();
                fill(255, 255, 255);
                rect(mouseXForAbductionLight - (70 * sizeOfLight / 2), mouseYForAbductionLight + (65 * sizeOfLight / 2), 70 * sizeOfLight, 800);
                isThereLight = true;
              }
              for (let i = 0; i < positionsAndSpeedOfCharacters.length; i++) {
                if (positionsAndSpeedOfCharacters[i][0] > mouseX - 49 && positionsAndSpeedOfCharacters[i][0] < mouseX + 49 && isThereLight) {
                  let randomStart = random(1, 2); 
                  if (randomStart >= 1.5) {
                    positionsAndSpeedOfCharacters[i][0] = -400;
                  } else {
                    positionsAndSpeedOfCharacters[i][0] = 1000;
                  }
                  currentScore++;
                } 
              }
            }
          };
        };


        //SCORE
        let currentScore = 0;
        let goal = 6;
        let level = 1;
        let lives = 3;
        let countdown = 3000;

        //***Score function in Draw function
        const score = () => {
          fill(255, 255, 255);
          rect(300, 0, 180, 110);
          fill(0, 0, 0);
          textSize(20);
          text("Goal: " + goal + " aliens", 325, 20);
          text("Current: " + currentScore + " aliens", 305, 40);
          text("Level: " + level, 360, 60);
          text((countdown/100).toFixed(1), 375, 80)
          text("Lives: " + lives, 360, 100);
          if (!isKeyPressed) {
            countdown -= 3;
          }
        };
        

        //TIME IS UP
        //***Time is up function in Draw function
        const timeIsUp = () => {
          textSize(60);
          fill(255, 255, 255);
          text("Time is up", 253, 170);
          fill(0, 0, 0);
          text("Time is up", 250, 170);
          fill(255, 255, 255);
          rect(280, 420, 215, 80);
          fill(0, 0, 0);
          stroke(0, 0, 0);
          textSize(40)
          text("Try again!", 300, 470);
          mousePressed = () => {
            if (mouseX > 280 && mouseX < 480 && mouseY > 420 && mouseY < 500) {
              currentScore = 0;
              countdown = 3000;
              lives -= 1;
            }
          }
        }
        

        //ANIMATION WITH SPIRAL
        let growthOfSpiral = 1;

        //Array of random colors for animation with spiral
        let colorsOfAnimationWithSpiral = [[random(0, 255), true],
                                           [random(0, 255), true],
                                           [random(0, 255), true]
        ];


        //CONGRATULATIONS
        //***Congratulations function in Draw function
        const congratulations = () => {
          fill(255, 255, 255)
          textSize(90);
          text("Congratulations!", 74, 200);
          fill(0, 0, 0);
          textSize(90)
          text("Congratulations!", 70, 200);
          
          stroke(0, 0, 0);
          fill(255, 255, 255);
          rect(280, 420, 200, 80);
          fill(0, 0, 0);
          textSize(40)
          text("Next level", 290, 470);
          mousePressed = () => {
            if (mouseX > 280 && mouseX < 480 && mouseY > 420 && mouseY < 500) {
              currentScore = 0;
              countdown = 3000;
              goal += 3;
              growthOfSpiral = 1;
              level++;
            }
          }
          finalAnimationWithSpiral(random(0, 800), random(0, 660), false);
        }


        //FINAL ANIMATION WITH SPIRAL
        //***Final animation function in Draw function
        const finalAnimationWithSpiral = (xSpiral, ySpiral, hasStroke) => {
          for (let i = 0; i < colorsOfAnimationWithSpiral.length; i++) {
            
            if (colorsOfAnimationWithSpiral[i][0] < 0) {
              colorsOfAnimationWithSpiral[i][1] = true;
            } else if (colorsOfAnimationWithSpiral[i][0] > 255) {
              colorsOfAnimationWithSpiral[i][1] = false;
            }

            if (colorsOfAnimationWithSpiral[i][1] === true) {
              colorsOfAnimationWithSpiral[i][0] += 0.55;
            } else {
              colorsOfAnimationWithSpiral[i][0] -= 0.55;
            }
          }

          let angle = 0.08 * growthOfSpiral;
          let x = (1 + angle)*Math.cos(angle);
          let y = (1 + angle)*Math.sin(angle);
          fill(colorsOfAnimationWithSpiral[0][0], colorsOfAnimationWithSpiral[1][0], colorsOfAnimationWithSpiral[2][0]);
          
          if (hasStroke === true) {
            stroke(0, 0, 0);
            strokeWeight(1);          
          } else {
            noStroke();
          }

          ellipse((x * 0.013 * growthOfSpiral) + xSpiral, (y * 0.013 * growthOfSpiral) + ySpiral, growthOfSpiral * 0.2, growthOfSpiral * 0.2);
          growthOfSpiral += 0.5;
        }

        //GAME OVER
        //Game over function in Draw function
        const gameOver = () => {
          finalAnimationWithSpiral(400, 330, true);
          textSize(60);
          fill(255, 255, 255);
          text("GAME OVER", 203, 170);
          fill(0, 0, 0);
          text("GAME OVER", 200, 170);
          fill(255, 255, 255);

          text("Your record: Level " + level, 203 - 80, 250);
          fill(0, 0, 0);
          text("Your record: Level " + level, 200 - 80, 250);
          fill(255, 255, 255);

          rect(275, 420, 240, 80);
          fill(0, 0, 0);
          stroke(0, 0, 0);
          textSize(40)
          text("Play again!", 300, 470);
          mousePressed = () => {
            if (mouseX > 280 && mouseX < 480 && mouseY > 420 && mouseY < 500) {
              currentScore = 0;
              countdown = 3000;
              lives = 3;
              growthOfSpiral = 1;
              level = 1;
              goal = 6;
            }
          }
        }

        //DRAW FUNCTION (MAIN)
        draw = () => {
          if (currentScore < goal && countdown > 0) {
            sky();        
            sun();
            moon();
            stars();
            pyramid();
            salesforce();
            clouds();
            buildings();
            paintedLadies();
            reductionColorNight();
            crosswalkStreetAndGrass();          
            if (isIntroduction) {
              introduction();
            } else {
              if (isKeyPressed) {
                instructions();
                score();

              } else {
                characters();  
                ufo();
                lightOfUFO();
                score();           
              }
            }
          } else if (countdown === 0) {
            if (lives > 1) {
              timeIsUp();
            } else if (lives === 1 && currentScore < goal) {              
              gameOver();
            }
          } else {
            congratulations();
          }
        }      
      }
    };

    var canvas = document.getElementById("mycanvas"); 
    var processingInstance = new Processing(canvas, sketchProc); 
 </script>
</html>