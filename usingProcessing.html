<!DOCTYPE html>
<html> 
 <head>
    <title>Project Johan Andres Ochoa</title> 
</head>
 <body>
    <p align="center"> 
      <canvas id="mycanvas"></canvas> 
    </p>
 </body>
 
 <script src="https://cdn.jsdelivr.net/processing.js/1.4.8/processing.min.js"></script> 
 
 <script>
    const sketchProc = (processingInstance) => {
     with (processingInstance) {
        //THE FOLLOWING CODE IS WRITEN BY JOHAN ANDRES OCHOA
        //jandresochoa91@gmail.com
       
        //WHEN I USE X AND Y, I USUALLY REFFER TO X AXIS AND Y AXIS. 
        //Example: sizeXStar, randomXForCharacters, randomXForClouds, etc

        //I'VE USED *** IN COMMENTS TO REFFER FUNCTIONS IN THE DRAW FUNCTION (MAIN)

        size(800, 650); 
        frameRate(300);


        //SKY
        let colorOfSky = [0, 228, 255];

        //***Sky function in Draw function
        const sky =  () => {
          background(colorOfSky[0], colorOfSky[1], colorOfSky[2]);
          if (sunMovement < -400 && colorOfSky[2] > 0) {
            if (colorOfSky[1] > 0) {
              colorOfSky[1] -= 5;
            } else {
              colorOfSky[1] = 0;
              if (colorOfSky[2] <= 40) {
                colorOfSky[2] = 40;    //Defined 40 because I didn't want the sky to be totally black
              } else {
                colorOfSky[2] -= 5;
              }
            }
          } else if (sunMovement > -200 && colorOfSky[1] < 228) {  //When the sun.....
            if (colorOfSky[2] < 255) {
              colorOfSky[2] += 4;
            } else {
              colorOfSky[1] += 4;
            }
          }
        };  


        //SUN
        let sunMovement = 380;
        
        //***Sun function in Draw function
        const sun = () => {
          fill(255, 255, 0);
          noStroke();
          ellipse(200, sunMovement, 200, 200);
          noFill();
          stroke(0, 0, 0);
          strokeWeight(3);
          arc(200, sunMovement, 150, 100, 0, PI);
          ellipse(250, sunMovement, 10, 10);
          ellipse(153, sunMovement, 10, 10);
          fill(0, 0, 0);
          sunMovement -= 5;
          
          if (colorOfSky[2] <= 60 && sunMovement === -1300) {    //Separate in different functions
            sunMovement = 750;
          }
        };


        //MOON
        let moveMoonX = 850;
        let moveMoonY = 200;
        let moonPhase = 1;    //There are 3 phases in this code: 1: Waxing Crescent, 2: First Quarter, 3: Full.

        //***Moon function in Draw function
        const moon = () => {
          if (colorOfSky[2] <= 160) {
            noStroke();
            fill(255, 255, 255);
            ellipse(moveMoonX, moveMoonY, 50, 50);

            if (moonPhase === 1) {
              fill(colorOfSky[0], colorOfSky[1], colorOfSky[2]);
              ellipse(moveMoonX - 10, moveMoonY, 50, 50);
            } else if (moonPhase === 2) {
              fill(colorOfSky[0], colorOfSky[1], colorOfSky[2]);
              rect(moveMoonX - 50, moveMoonY - 30, 50, 70);
            } else if (moonPhase > 3) {
              moonPhase = 1
            }
            moveMoonX -= 2;
            moveMoonY -= 2;
          } else {
            moveMoonX = 850;
            moveMoonY = 200;
          }
          if (colorOfSky[2] === 161) {
            moonPhase += 1;
          }
        };


        //STARS
        let sizeXStar = 0.0010;
        let sizeYStar = 0.0010;
        let isMidnight = false;

        //Array with position of random stars
        let allTheStars = [];
        for (let i = 0; i < 50; i++) {
          let randomXStars = random(0, 800);
          let randomYStars = random(0, 400);
          allTheStars.push([randomXStars, randomYStars]); 
        }

        //***Stars function in Draw function
        const stars = () => {
          for (var i = 0; i < allTheStars.length; i++) {
            
            if (colorOfSky[2] < 255) {
              
              fill(255, 255, 255);
              noStroke();
              ellipse(allTheStars[i][0], allTheStars[i][1], sizeXStar, sizeYStar);
              
              if (isMidnight) {
                sizeXStar -= 0.0010;
                sizeYStar -= 0.0010;
              } else {
                sizeXStar += 0.0010;
                sizeYStar += 0.0010;
              }
              
              if (sizeXStar > 4) {
                sizeXStar -= 0.0010;
                sizeYStar -= 0.0010;
                isMidnight = true;
              } 

              if (colorOfSky[2] > 250) {
                sizeXStar = 0.0010;
                sizeYStar = 0.0010;
                isMidnight = false;
              }
            } 
          }
        };


        //TRANSAMERICA PYRAMID BUILDING
        //***Pyramid function in Draw function
        const pyramid = () =>  {
          stroke(0, 0, 0);
          strokeWeight(3);
          let randomRPyramidColor = random(0, 255);
          let randomGPyramidColor = random(0, 255);
          let randomBPyramidColor = random(0, 255);

          if (colorOfSky[2] < 255) {
            fill(randomRPyramidColor, randomGPyramidColor, randomBPyramidColor);
          } else {
            fill(buildingsAttributes[0][3][0],  //I used position 0, but you can use any other position of the array
                 buildingsAttributes[0][3][1],  //I used position 0, but you can use any other position of the array
                 buildingsAttributes[0][3][2]   //I used position 0, but you can use any other position of the array
            );
          }

          triangle(100, 450, 150, 150, 200, 450);
          rect(140, 225, 20, 70);
        };


        //SALESFORCE BUILDING
        //***Salesforse function in Draw function
        const salesforce = () => {
          let randomRSalesforceColor = random(0, 255);
          let randomGSalesforceColor = random(0, 255);
          let randomBSalesforceColor = random(0, 255);

          if (colorOfSky[2] < 255) {
            fill(randomRSalesforceColor, randomGSalesforceColor, randomBSalesforceColor);
          } else {
            fill(buildingsAttributes[1][3][0],  //I used position 1, but you can use any other position of the array
                 buildingsAttributes[1][3][1],  //I used position 1, but you can use any other position of the array
                 buildingsAttributes[1][3][2]   //I used position 1, but you can use any other position of the array
            );
          }

          stroke(0, 0, 0);
          strokeWeight(3);
          ellipse(520, 270, 50, 370);

          strokeWeight(3);
          line(505, 120, 534, 120);

          noStroke();
          fill(colorOfSky[0], colorOfSky[1], colorOfSky[2]);
          rect(500, 79, 40, 40);
        };
        

        //CLOUDS
        //Clouds attributes
        let cloudsAttributes = []; 
        for (let i = 1; i < 7; i++) {
          let randomXForClouds = random(0, 800);
          let setYForClouds = (50 * i) - 50;
          let randomSpeedForClouds = random(1, 5);

          cloudsAttributes.push([setYForClouds,  
                                 randomSpeedForClouds,
                                 randomXForClouds
                                ]
          );          
        }

        //***Clouds function in Draw function
        const clouds = () => {
          noStroke();
          fill(255, 255, 255);

          for (let i = 0; i < cloudsAttributes.length; i++) {
            let xCloud = cloudsAttributes[i][0];
            ellipse(cloudsAttributes[i][2]     , xCloud, 126, 97);
            ellipse(cloudsAttributes[i][2] + 62, xCloud, 70 , 60);
            ellipse(cloudsAttributes[i][2] - 62, xCloud, 70 , 60);
            
            if (i % 2 === 0) {
              if (cloudsAttributes[i][2] > 1000) {
                cloudsAttributes[i][2] = -200;
              } else {
                cloudsAttributes[i][2] += cloudsAttributes[i][1];
              }
            } else {
              if (cloudsAttributes[i][2] < -100) {
                cloudsAttributes[i][2] = 1000;
              } else {
                cloudsAttributes[i][2] -= cloudsAttributes[i][1];
              }
            }
          }
        };


        //BUILDINGS (NEITHER TRANSAMERICA PYRAMID NOR SALESFORCE INCLUIDED)
        //Array of random mumbers to make buildings and define colors
        let buildingsAttributes = [];
        for (let i = 0; i < 60; i++) {
          let randomXForBuildings = random(-40, 800);
          let randomWeigthOfBuildings = random(30, 50);
          let randomHeightOfBuildings = random(-200, -100);
          let randomRForBuildingColor = random(140, 180);
          let randomGForBuildingColor = random(140, 180);
          let randomBForBuildingColor = random(140, 180);
          buildingsAttributes.push([randomXForBuildings,
                                    randomWeigthOfBuildings,
                                    randomHeightOfBuildings,
                                    [randomRForBuildingColor, randomGForBuildingColor, randomBForBuildingColor]
                                   ]
          );
        }

        //***Buildings function in Draw function
        const buildings = () => {
          stroke(0, 0, 0);

          for (let j = 0; j < buildingsAttributes.length; j++) {
          
            let randomRBuildingsColor = random(0, 255);
            let randomGBuildingsColor = random(0, 255);
            let randomBBuildingsColor = random(0, 255);

            if (colorOfSky[2] < 255) {
              fill(randomRBuildingsColor, randomGBuildingsColor, randomBBuildingsColor);
            } else {
              fill(buildingsAttributes[j][3][0], buildingsAttributes[j][3][1], buildingsAttributes[j][3][2]);
            }

            stroke(0, 0, 0);
            strokeWeight(3);
            rect(buildingsAttributes[j][0],
                                       400,
                 buildingsAttributes[j][1],
                 buildingsAttributes[j][2]
            );
          }
        };
 

        //PAINTED LADIES
        let colorsForPaintedLadies = {
          1: [255, 100, 100],
          2: [255, 150,  60],
          3: [255, 255, 100],
          4: [100, 255, 100],
          5: [84,  89,  255],
          6: [133, 100, 255]
        };

        //***Painted Ladies function in Draw function
        const paintedLadies = () => {
          fill(225, 204, 127);
          let movePaintedLadyToX = -10;
          let movePaintedLadyToY = -60;
          let randomNumberChangingPaintedLadies = Math.round(random(1, 2));
            
          for (let i = 1; i < 6 + 1; i++) {            
            if (colorOfSky[2] < 255) {
              if (randomNumberChangingPaintedLadies % 2 === 0) {
                fill(random(0, 255), random(0, 255), random(0, 255));
              } else {
                fill(colorsForPaintedLadies[i][0], colorsForPaintedLadies[i][1], colorsForPaintedLadies[i][2]);  
              }           
            } else {
              fill(colorsForPaintedLadies[i][0], colorsForPaintedLadies[i][1], colorsForPaintedLadies[i][2]);
            }
            stroke(0, 0, 0);
            strokeWeight(3);
            rect(10 + movePaintedLadyToX, 450 + movePaintedLadyToY, 120, 180);
            triangle(5  + movePaintedLadyToX, 450 + movePaintedLadyToY,
                    70  + movePaintedLadyToX, 385 + movePaintedLadyToY,
                    135 + movePaintedLadyToX, 450 + movePaintedLadyToY
            );
            quad(130 + movePaintedLadyToX, 450 + movePaintedLadyToY,
                 130 + movePaintedLadyToX, 630 + movePaintedLadyToY,
                 265 + movePaintedLadyToX, 610 + movePaintedLadyToY,
                 265 + movePaintedLadyToX, 440 + movePaintedLadyToY
            );
            fill(40, 40, 40);
            quad(70 + movePaintedLadyToX, 385 + movePaintedLadyToY,
                135 + movePaintedLadyToX, 450 + movePaintedLadyToY,
                270 + movePaintedLadyToX, 440 + movePaintedLadyToY,
                200 + movePaintedLadyToX, 380 + movePaintedLadyToY
            );
            movePaintedLadyToX += 130;
            movePaintedLadyToY -= 10;
          }             
        };

        
        //CROSSWALK, STREET AND GRASS
        //***function in Draw function
        const crosswalkStreetAndGrass = () => {
          stroke(0, 0, 0);
          strokeWeight(3);
          //Crosswalk
          fill(80, 80, 80);
          quad(0, 650, 0, 570, 1000, 495, 650, 800);
          
          //Street
          fill(120, 120, 120);
          quad(0, 650, 0, 580, 1000, 505, 650, 800);
          
          //Upper Green field
          fill(0, 180, 0);
          quad(0, 650, 0, 570, 1000, 610, 650, 800);
          
          //Lower Green Field
          fill(0, 255, 0);
          rect(0, 620, 800, 30);
        };


        //CHARACTERS
        //Random positions and speed for characters 
        let positionsAndSpeedOfCharacters = [];
        for (let i = 0; i < 3; i++) {
          let randomXForCharacters = random(0, 740);
          let randomYForCharacters = random(0, 45);
          let randomSpeedForCharacters = random(1, 30);
          let randomNewPositionOfCharacters = random(0, 800);
          positionsAndSpeedOfCharacters.push([randomXForCharacters,   
                                              randomYForCharacters,
                                              randomSpeedForCharacters,
                                              randomNewPositionOfCharacters,
                                              true     //True or false to know if caracter is turning right or left
                                             ]
          );
        }

        //***Characters function in Draw function
        const characters = () => {
          for (let i = 0; i < positionsAndSpeedOfCharacters.length; i++) {
            noStroke();
            
            fill(0, 0, 0);
            ellipse(positionsAndSpeedOfCharacters[i][0], 643 - positionsAndSpeedOfCharacters[i][1], 15, 10);
            
            fill(255, 60, 0);
            ellipse(positionsAndSpeedOfCharacters[i][0], 633 - positionsAndSpeedOfCharacters[i][1], 30, 20);
            
            fill(218, 159, 74);
            ellipse(positionsAndSpeedOfCharacters[i][0], 609 - positionsAndSpeedOfCharacters[i][1], 50, 40);
            
            stroke(0, 0, 0);
            strokeWeight(2)            
            arc(-12  + positionsAndSpeedOfCharacters[i][0], 613 - positionsAndSpeedOfCharacters[i][1], 8 ,  10, -3,  0);
            arc(12  + positionsAndSpeedOfCharacters[i][0], 613 - positionsAndSpeedOfCharacters[i][1], 8 ,  10, -3,  0);
            fill(0, 0, 0);
            arc(positionsAndSpeedOfCharacters[i][0], 620 - positionsAndSpeedOfCharacters[i][1], 12,  10,  0, PI);
            arc(positionsAndSpeedOfCharacters[i][0], 605 - positionsAndSpeedOfCharacters[i][1], 55, -55,  0, PI);

            
            if (positionsAndSpeedOfCharacters[i][3] > positionsAndSpeedOfCharacters[i][0] && positionsAndSpeedOfCharacters[i][4]) {
              positionsAndSpeedOfCharacters[i][0] += positionsAndSpeedOfCharacters[i][2];
            } else {
              if (positionsAndSpeedOfCharacters[i][4]) {
                positionsAndSpeedOfCharacters[i][4] = false;
                positionsAndSpeedOfCharacters[i][3] = random(-400, 1200);
              }
            }

            if (positionsAndSpeedOfCharacters[i][3] <= positionsAndSpeedOfCharacters[i][0] && !positionsAndSpeedOfCharacters[i][4]) {
              positionsAndSpeedOfCharacters[i][0] -= positionsAndSpeedOfCharacters[i][2];
            } else {
              if (!positionsAndSpeedOfCharacters[i][4]) {
                positionsAndSpeedOfCharacters[i][4] = true;
                positionsAndSpeedOfCharacters[i][3] = random(-400, 1200);
              }
            }
          }
        };
        

        //UFO
        //***ufo function in Draw function
        const ufo = () => {
          let mouseXForUFO = mouseX;
          let mouseYForUFO = mouseY;
          let sizeOfUFO = mouseYForUFO * 0.006;

          if (mouseYForUFO > 220) {
            mouseYForUFO = 220;
            sizeOfUFO = 1.3;
          }
          stroke(0, 0, 0);
          strokeWeight(3);
          fill(38, 25, 25);
          ellipse(mouseXForUFO, mouseYForUFO + (sizeOfUFO * 1) ,  70 * sizeOfUFO, 70 * sizeOfUFO);
          fill(112, 59, 112);
          ellipse(mouseXForUFO, mouseYForUFO + (sizeOfUFO * 15), 150 * sizeOfUFO, 50 * sizeOfUFO);
          noStroke()
          fill(255, 255, 255);
          ellipse(mouseXForUFO, mouseYForUFO + (sizeOfUFO * 30),  70 * sizeOfUFO, 25 * sizeOfUFO);
        };


        //LIGTH OF UFO
        //***Light of UFO function in Draw function
        const ligthOfUFO = () => {  //Change light
          mousePressed = () => {
            if (currentScore < goal && countdown > 0) {
              let mouseXForAbductionLight = mouseX;
              let mouseYForAbductionLight = mouseY;
              let sizeOfLigth = mouseYForAbductionLight * 0.006;
              let isThereLight = false;
              if (mouseYForAbductionLight > 210) {
                mouseYForAbductionLight = 220;
                sizeOfLigth = 1.3;
              }
              if (mouseY < 270) {
                noStroke();
                fill(255, 255, 255);
                rect(mouseXForAbductionLight - (70 * sizeOfLigth / 2), mouseYForAbductionLight + (65 * sizeOfLigth / 2), 70 * sizeOfLigth, 800);
                isThereLight = true;
              }
              for (let i = 0; i < positionsAndSpeedOfCharacters.length; i++) {
                if (positionsAndSpeedOfCharacters[i][0] > mouseX - 49 && positionsAndSpeedOfCharacters[i][0] < mouseX + 49 && isThereLight) {
                  let randomStart = random(1, 2); 
                  if (randomStart >= 1.5) {
                    positionsAndSpeedOfCharacters[i][0] = -400;
                  } else {
                    positionsAndSpeedOfCharacters[i][0] = 1000;
                  }
                  currentScore++;
                } 
              }
            }
          };
        };


        //SCORE
        let currentScore = 0;
        let goal = 6;
        let level = 1;
        let lives = 3;
        let countdown = 3000;

        //***Score function in Draw function
        const score = () => {
          rect(300, 0, 180, 110);
          fill(0, 0, 0);
          textSize(20);
          text("Goal: " + goal + " people", 325, 20);
          text("Current: " + currentScore + " people", 305, 40);
          text("Level: " + level, 360, 60);
          text((countdown/100).toFixed(1), 375, 80)
          text("Lives: " + lives, 360, 100);
          countdown -= 3;
        };
        

        //YOU LOSE
        //***you lose function in Draw function
        const youLose = () => {
          textSize(60);
          fill(255, 255, 255);
          text("You lose", 263, 170);
          fill(0, 0, 0);
          text("You lose", 260, 170);
          fill(255, 255, 255);
          rect(280, 420, 200, 80);
          fill(0, 0, 0);
          stroke(0, 0, 0);
          textSize(40)
          text("Try again", 300, 470);
          mousePressed = () => {
            if (mouseX > 280 && mouseX < 480 && mouseY > 420 && mouseY < 500) {
              currentScore = 0;
              countdown = 3000;
              lives -= 1;
            }
          }
        }
        

        //ANIMATION WITH SPIRAL
        let growthOfSpiral = 1;

        //Array of random colors for animation with spiral
        let colorsOfAnimationWithSpiral = [[random(0, 255), true],
                                           [random(0, 255), true],
                                           [random(0, 255), true]
        ];


        //CONGRATULATIONS
        //***Congratulations function in Draw function
        const congratulations = () => {
          fill(255, 255, 255)
          textSize(90);
          text("Congratulations!", 74, 200);
          fill(0, 0, 0);
          textSize(90)
          text("Congratulations!", 70, 200);

          fill(255, 255, 255);
          rect(280, 420, 200, 80);
          fill(0, 0, 0);
          stroke(0, 0, 0);
          textSize(40)
          text("Next level", 290, 470);
          mousePressed = () => {
            if (mouseX > 280 && mouseX < 480 && mouseY > 420 && mouseY < 500) {
              currentScore = 0;
              countdown = 3000;
              goal += 3;
              growthOfSpiral = 1;
              level++;
            }
          }
          finalAnimationWithSpiral(random(0, 800), random(0, 660));
        }



        //***Final animation function in Draw function
        const finalAnimationWithSpiral = (xSpiral, ySpiral) => {
          for (let i = 0; i < colorsOfAnimationWithSpiral.length; i++) {
            
            if (colorsOfAnimationWithSpiral[i][0] < 0) {
              colorsOfAnimationWithSpiral[i][1] = true;
            } else if (colorsOfAnimationWithSpiral[i][0] > 255) {
              colorsOfAnimationWithSpiral[i][1] = false;
            }
            if (colorsOfAnimationWithSpiral[i][1] === true) {
              colorsOfAnimationWithSpiral[i][0] += 0.55;
            } else {
              colorsOfAnimationWithSpiral[i][0] -= 0.55;
            }
          }
          let angle = 0.08 * growthOfSpiral;
          let x = (1+angle)*Math.cos(angle);
          let y = (1+angle)*Math.sin(angle);
          fill(colorsOfAnimationWithSpiral[0][0], colorsOfAnimationWithSpiral[1][0], colorsOfAnimationWithSpiral[2][0]);
          strokeWeight(1);          
          ellipse((x * 0.013 * growthOfSpiral) + xSpiral, (y * 0.013 * growthOfSpiral) + ySpiral, growthOfSpiral * 0.2, growthOfSpiral * 0.2);
          growthOfSpiral += 0.5;
        }

        //GAME OVER
        //Game over function in Draw function
        const gameOver = () => {
          finalAnimationWithSpiral(400, 330);
          textSize(60);
          fill(255, 255, 255);
          text("GAME OVER", 203, 170);
          fill(0, 0, 0);
          text("GAME OVER", 200, 170);
          fill(255, 255, 255);

          text("Your record: Level " + level, 203 - 80, 250);
          fill(0, 0, 0);
          text("Your record: Level " + level, 200 - 80, 250);
          fill(255, 255, 255);

          rect(275, 420, 240, 80);
          fill(0, 0, 0);
          stroke(0, 0, 0);
          textSize(40)
          text("Play again!", 300, 470);
          mousePressed = () => {
            if (mouseX > 280 && mouseX < 480 && mouseY > 420 && mouseY < 500) {
              currentScore = 0;
              countdown = 3000;
              lives = 3;
              growthOfSpiral = 1;
              level = 1;
              goal = 6;
            }
          }
        }

        //DRAW FUNCTION (MAIN)
        draw = () => {
          if (currentScore < goal && countdown > 0) {
            sky();        
            sun();
            moon();
            stars();
            pyramid();
            salesforce();
            clouds();
            buildings();
            paintedLadies();
            crosswalkStreetAndGrass();          
            characters();  
            ufo();
            ligthOfUFO();
            score();           
          } else  if (countdown === 0) {
            if (lives > 1) {
              youLose();
            } else if (lives === 1 && currentScore < goal) {              
              gameOver();
            }
          } else {
            congratulations();
          }
        }      
      }
    };

    var canvas = document.getElementById("mycanvas"); 
    var processingInstance = new Processing(canvas, sketchProc); 
 </script>
</html>